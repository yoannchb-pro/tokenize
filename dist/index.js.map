{"version":3,"file":"index.js","sources":["../src/index.ts"],"sourcesContent":["type MatcherResult<T extends Tokens, D extends string, A extends boolean> = {\r\n  type: TokenType<T, D, A>;\r\n  value: string;\r\n  groups?: Record<string, string>;\r\n  index: number;\r\n};\r\n\r\ntype Tokens = {\r\n  [key: string]: RegExp;\r\n};\r\n\r\ntype TokenType<T extends Tokens, D extends string, A extends boolean> =\r\n  | keyof T\r\n  | (A extends true ? D | Omit<string, keyof T | D> : D);\r\n\r\ntype Token<T extends Tokens, D extends string, A extends boolean> = {\r\n  type: TokenType<T, D, A>;\r\n  value: string;\r\n  groups?: Record<string, string>;\r\n  startLine: number;\r\n  endLine: number;\r\n  startColumn: number;\r\n  endColumn: number;\r\n};\r\n\r\ntype Options<T extends Tokens, D extends string, A extends boolean> = {\r\n  tokens: T;\r\n  defaultType: D;\r\n  prioritize?: boolean;\r\n  callback?: (\r\n    token: Token<T, D, A>,\r\n    prevTokens: Token<T, D, A>[]\r\n  ) => Token<T, D, A> | null;\r\n  concatDefaultType?: boolean;\r\n  authorizeAdditionalTokens?: A;\r\n};\r\n\r\nconst defaultOptions = {\r\n  defaultType: \"UNKNOWN\",\r\n  concatDefaultType: true,\r\n} as const satisfies Partial<Options<{}, \"UNKNOWN\", false>>;\r\n\r\ntype ConstructorOptions<\r\n  T extends Tokens,\r\n  D extends string,\r\n  A extends boolean\r\n> = Omit<Options<T, D, A>, keyof typeof defaultOptions> &\r\n  Partial<Pick<Options<T, D, A>, keyof typeof defaultOptions>>;\r\n\r\n/**\r\n * Tokenize any string with given tokens\r\n */\r\nclass Tokenizer<\r\n  T extends Tokens,\r\n  D extends string = \"UNKNOWN\",\r\n  A extends boolean = false\r\n> {\r\n  public static BUILT_IN_RULES = {\r\n    WORD: /\\w+/,\r\n    NUMBER: /\\d+(?:\\.\\d+)?/,\r\n\r\n    ONE_LINE_COMMENT: /\\/\\/.*/,\r\n    MULTIPLE_LINE_COMMENT: /\\/\\*[\\s\\S]*?\\*\\//,\r\n\r\n    STRING: /(\"|'|`)(?<content>(?:\\\\\\1|.)*?)\\1/,\r\n    DOUBLE_QUOTE_STRING: /(\")(?<content>(?:\\\\\\1|.)*?)\\1/,\r\n    SINGLE_QUOTE_STRING: /(')(?<content>(?:\\\\\\1|.)*?)\\1/,\r\n    GRAVE_ACCENT_STRING: /(`)(?<content>(?:\\\\\\1|.)*?)\\1/,\r\n\r\n    WHITE_SPACES: /\\s+/,\r\n    NEW_LINES: /\\n+/,\r\n  } as const satisfies Record<string, RegExp>;\r\n  private options: Options<T, D, A>;\r\n\r\n  constructor(_options: ConstructorOptions<T, D, A>) {\r\n    if (!_options || !_options.tokens)\r\n      throw new Error('Invalide options: \"tokens\" is required');\r\n    this.options = Object.assign({}, defaultOptions, _options);\r\n  }\r\n\r\n  /**\r\n   * Get the default type if no token was match\r\n   * @returns\r\n   */\r\n  getDefaultType(): D {\r\n    return this.options.defaultType;\r\n  }\r\n\r\n  /**\r\n   * Get the list registered of the tokens\r\n   * @returns\r\n   */\r\n  getTokens(): T {\r\n    return this.options.tokens;\r\n  }\r\n\r\n  /**\r\n   * Get the list of tokens name\r\n   * @returns\r\n   */\r\n  getTokensName(): (keyof T | D)[] {\r\n    return [...Object.keys(this.options.tokens), this.getDefaultType()];\r\n  }\r\n\r\n  /**\r\n   * Tokenize a string\r\n   * @param str\r\n   * @returns\r\n   */\r\n  tokenize(str: string): Token<T, D, A>[] {\r\n    if (typeof str !== \"string\") return [];\r\n\r\n    const tokens: Token<T, D, A>[] = [];\r\n\r\n    const defaultType = this.getDefaultType();\r\n    const concatDefaultType = this.options.concatDefaultType;\r\n    const tokensList = Object.entries(this.options.tokens);\r\n\r\n    let index = 0;\r\n    let line = 0;\r\n    let column = 0;\r\n\r\n    while (index < str.length) {\r\n      const remaining = str.slice(index);\r\n\r\n      let result: MatcherResult<T, D, A> | null = null;\r\n\r\n      // Check if any regex is matching\r\n      let priorIndex: null | number = null;\r\n      for (const [type, reg] of tokensList) {\r\n        reg.lastIndex = 0;\r\n        const match = reg.exec(remaining);\r\n\r\n        if (\r\n          match &&\r\n          match.index !== 0 &&\r\n          this.options.prioritize === true &&\r\n          priorIndex === null\r\n        )\r\n          priorIndex = match.index;\r\n\r\n        if (\r\n          match &&\r\n          match.index === 0 &&\r\n          (priorIndex === null || match[0].length <= priorIndex)\r\n        ) {\r\n          result = {\r\n            type,\r\n            value: match[0],\r\n            groups: match.groups,\r\n            index: 0,\r\n          };\r\n          break;\r\n        }\r\n      }\r\n\r\n      // No match -> default token\r\n      if (!result) {\r\n        result = {\r\n          type: defaultType,\r\n          value: remaining[0],\r\n          index: 0,\r\n        };\r\n      }\r\n\r\n      // Line, column calculation\r\n      const value = result.value;\r\n      const lines = value.split(\"\\n\");\r\n      const startLine = line;\r\n      const startColumn = column;\r\n      let endLine = line;\r\n      let endColumn = column;\r\n\r\n      if (lines.length > 1) {\r\n        endLine = line + lines.length - 1;\r\n        endColumn = lines[lines.length - 1].length;\r\n      } else {\r\n        endColumn = column + value.length;\r\n      }\r\n\r\n      // Update current line/column\r\n      line = endLine;\r\n      column = endColumn;\r\n\r\n      let token: Token<T, D, A> | null = {\r\n        type: result.type,\r\n        value: result.value,\r\n        ...(result.groups ? { groups: result.groups } : {}),\r\n        startLine,\r\n        startColumn,\r\n        endLine,\r\n        endColumn,\r\n      };\r\n\r\n      token = this.options.callback\r\n        ? this.options.callback(token, tokens)\r\n        : token;\r\n\r\n      // We update the char index based on what we have match\r\n      index += value.length;\r\n\r\n      // Check the new token returned by the callback\r\n      if (token === null) continue;\r\n      if (\r\n        !this.options.authorizeAdditionalTokens &&\r\n        !this.getTokensName().includes(token.type as keyof T | D)\r\n      ) {\r\n        throw new Error(\r\n          `Unknown token type returned by the callback: \"${\r\n            token.type as string\r\n          }\" (If you want to allow other types please set authorizeAdditionalTokens to true)`\r\n        );\r\n      }\r\n\r\n      const isTokenDefaultType = token.type === defaultType;\r\n      const needConcatenation =\r\n        concatDefaultType &&\r\n        isTokenDefaultType &&\r\n        tokens.length !== 0 &&\r\n        tokens[tokens.length - 1].type === defaultType;\r\n      if (needConcatenation) {\r\n        // Concatenation with the last token if needed\r\n        const lastToken = tokens[tokens.length - 1];\r\n        lastToken.value += token.value;\r\n        lastToken.endColumn = token.endColumn;\r\n        lastToken.endLine = token.endLine;\r\n      } else {\r\n        tokens.push(token);\r\n      }\r\n    }\r\n\r\n    return tokens;\r\n  }\r\n}\r\n\r\nexport default Tokenizer;\r\n"],"names":["defaultOptions","defaultType","concatDefaultType","Tokenizer","constructor","_options","tokens","Error","this","options","Object","assign","getDefaultType","getTokens","getTokensName","keys","tokenize","str","tokensList","entries","index","line","column","length","remaining","slice","result","priorIndex","type","reg","lastIndex","match","exec","prioritize","value","groups","lines","split","startLine","startColumn","endLine","endColumn","token","callback","authorizeAdditionalTokens","includes","isTokenDefaultType","lastToken","push","BUILT_IN_RULES","WORD","NUMBER","ONE_LINE_COMMENT","MULTIPLE_LINE_COMMENT","STRING","DOUBLE_QUOTE_STRING","SINGLE_QUOTE_STRING","GRAVE_ACCENT_STRING","WHITE_SPACES","NEW_LINES"],"mappings":"0OAqCA,MAAMA,EAAiB,CACrBC,YAAa,UACbC,mBAAmB,GAarB,MAAMC,EAsBJ,WAAAC,CAAYC,GACV,IAAKA,IAAaA,EAASC,OACzB,MAAM,IAAIC,MAAM,0CAClBC,KAAKC,QAAUC,OAAOC,OAAO,CAAA,EAAIX,EAAgBK,EAClD,CAMD,cAAAO,GACE,OAAOJ,KAAKC,QAAQR,WACrB,CAMD,SAAAY,GACE,OAAOL,KAAKC,QAAQH,MACrB,CAMD,aAAAQ,GACE,MAAO,IAAIJ,OAAOK,KAAKP,KAAKC,QAAQH,QAASE,KAAKI,iBACnD,CAOD,QAAAI,CAASC,GACP,GAAmB,iBAARA,EAAkB,MAAO,GAEpC,MAAMX,EAA2B,GAE3BL,EAAcO,KAAKI,iBACnBV,EAAoBM,KAAKC,QAAQP,kBACjCgB,EAAaR,OAAOS,QAAQX,KAAKC,QAAQH,QAE/C,IAAIc,EAAQ,EACRC,EAAO,EACPC,EAAS,EAEb,KAAOF,EAAQH,EAAIM,QAAQ,CACzB,MAAMC,EAAYP,EAAIQ,MAAML,GAE5B,IAAIM,EAAwC,KAGxCC,EAA4B,KAChC,IAAK,MAAOC,EAAMC,KAAQX,EAAY,CACpCW,EAAIC,UAAY,EAChB,MAAMC,EAAQF,EAAIG,KAAKR,GAUvB,GAPEO,GACgB,IAAhBA,EAAMX,QACsB,IAA5BZ,KAAKC,QAAQwB,YACE,OAAfN,IAEAA,EAAaI,EAAMX,OAGnBW,GACgB,IAAhBA,EAAMX,QACU,OAAfO,GAAuBI,EAAM,GAAGR,QAAUI,GAC3C,CACAD,EAAS,CACPE,OACAM,MAAOH,EAAM,GACbI,OAAQJ,EAAMI,OACdf,MAAO,GAET,KACD,CACF,CAGIM,IACHA,EAAS,CACPE,KAAM3B,EACNiC,MAAOV,EAAU,GACjBJ,MAAO,IAKX,MAAMc,EAAQR,EAAOQ,MACfE,EAAQF,EAAMG,MAAM,MACpBC,EAAYjB,EACZkB,EAAcjB,EACpB,IAAIkB,EAAUnB,EACVoB,EAAYnB,EAEZc,EAAMb,OAAS,GACjBiB,EAAUnB,EAAOe,EAAMb,OAAS,EAChCkB,EAAYL,EAAMA,EAAMb,OAAS,GAAGA,QAEpCkB,EAAYnB,EAASY,EAAMX,OAI7BF,EAAOmB,EACPlB,EAASmB,EAET,IAAIC,EAA+B,CACjCd,KAAMF,EAAOE,KACbM,MAAOR,EAAOQ,SACVR,EAAOS,OAAS,CAAEA,OAAQT,EAAOS,QAAW,CAAE,EAClDG,YACAC,cACAC,UACAC,aAWF,GARAC,EAAQlC,KAAKC,QAAQkC,SACjBnC,KAAKC,QAAQkC,SAASD,EAAOpC,GAC7BoC,EAGJtB,GAASc,EAAMX,OAGD,OAAVmB,EAAgB,SACpB,IACGlC,KAAKC,QAAQmC,4BACbpC,KAAKM,gBAAgB+B,SAASH,EAAMd,MAErC,MAAM,IAAIrB,MACR,iDACEmC,EAAMd,yFAKZ,MAAMkB,EAAqBJ,EAAMd,OAAS3B,EAM1C,GAJEC,GACA4C,GACkB,IAAlBxC,EAAOiB,QACPjB,EAAOA,EAAOiB,OAAS,GAAGK,OAAS3B,EACd,CAErB,MAAM8C,EAAYzC,EAAOA,EAAOiB,OAAS,GACzCwB,EAAUb,OAASQ,EAAMR,MACzBa,EAAUN,UAAYC,EAAMD,UAC5BM,EAAUP,QAAUE,EAAMF,OAC3B,MACClC,EAAO0C,KAAKN,EAEf,CAED,OAAOpC,CACR,SA/KaH,EAAA8C,eAAiB,CAC7BC,KAAM,MACNC,OAAQ,gBAERC,iBAAkB,SAClBC,sBAAuB,mBAEvBC,OAAQ,oCACRC,oBAAqB,gCACrBC,oBAAqB,gCACrBC,oBAAqB,gCAErBC,aAAc,MACdC,UAAW"}