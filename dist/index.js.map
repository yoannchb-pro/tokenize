{"version":3,"file":"index.js","sources":["../src/index.ts"],"sourcesContent":["type MatcherResult<T extends Tokens, D extends string, A extends boolean> = {\r\n  type: TokenType<T, D, A>;\r\n  value: string;\r\n  groups?: Record<string, string>;\r\n  index: number;\r\n};\r\n\r\ntype Tokens = {\r\n  [key: string]: RegExp;\r\n};\r\n\r\ntype TokenType<T extends Tokens, D extends string, A extends boolean> =\r\n  | keyof T\r\n  | (A extends true ? D | Omit<string, keyof T | D> : D);\r\n\r\ntype Token<T extends Tokens, D extends string, A extends boolean> = {\r\n  type: TokenType<T, D, A>;\r\n  value: string;\r\n  groups?: Record<string, string>;\r\n  startLine: number;\r\n  endLine: number;\r\n  startColumn: number;\r\n  endColumn: number;\r\n};\r\n\r\ntype Options<T extends Tokens, D extends string, A extends boolean> = {\r\n  tokens: T;\r\n  defaultType: D;\r\n  prioritize?: boolean;\r\n  callback?: (\r\n    token: Token<T, D, A>,\r\n    prevTokens: Token<T, D, A>[]\r\n  ) => Token<T, D, A> | null;\r\n  concatDefaultType?: boolean;\r\n  authorizeAdditionalTokens?: A;\r\n};\r\n\r\nconst defaultOptions = {\r\n  defaultType: \"UNKNOWN\",\r\n  concatDefaultType: true,\r\n  prioritize: true,\r\n} as const satisfies Partial<Options<{}, \"UNKNOWN\", false>>;\r\n\r\ntype ConstructorOptions<\r\n  T extends Tokens,\r\n  D extends string,\r\n  A extends boolean\r\n> = Omit<Options<T, D, A>, keyof typeof defaultOptions> &\r\n  Partial<Pick<Options<T, D, A>, keyof typeof defaultOptions>>;\r\n\r\n/**\r\n * Tokenize any string with given tokens\r\n */\r\nclass Tokenizer<\r\n  T extends Tokens,\r\n  D extends string = \"UNKNOWN\",\r\n  A extends boolean = false\r\n> {\r\n  public static BUILT_IN_RULES = {\r\n    WORD: /\\w+/,\r\n    NUMBER: /\\d+(?:\\.\\d+)?/,\r\n\r\n    ONE_LINE_COMMENT: /\\/\\/.*/,\r\n    MULTIPLE_LINE_COMMENT: /\\/\\*[\\s\\S]*?\\*\\//,\r\n\r\n    STRING: /(\"|'|`)(?<content>(?:\\\\\\1|.)*?)\\1/,\r\n    DOUBLE_QUOTE_STRING: /(\")(?<content>(?:\\\\\\1|.)*?)\\1/,\r\n    SINGLE_QUOTE_STRING: /(')(?<content>(?:\\\\\\1|.)*?)\\1/,\r\n    GRAVE_ACCENT_STRING: /(`)(?<content>(?:\\\\\\1|.)*?)\\1/,\r\n\r\n    WHITE_SPACES: /\\s+/,\r\n    NEW_LINES: /\\n+/,\r\n  } as const satisfies Record<string, RegExp>;\r\n  private options: Options<T, D, A>;\r\n\r\n  constructor(_options: ConstructorOptions<T, D, A>) {\r\n    if (!_options || !_options.tokens)\r\n      throw new Error('Invalide options: \"tokens\" is required');\r\n    this.options = Object.assign({}, defaultOptions, _options);\r\n  }\r\n\r\n  /**\r\n   * Get the default type if no token was match\r\n   * @returns\r\n   */\r\n  getDefaultType(): D {\r\n    return this.options.defaultType;\r\n  }\r\n\r\n  /**\r\n   * Get the list registered of the tokens\r\n   * @returns\r\n   */\r\n  getTokens(): T {\r\n    return this.options.tokens;\r\n  }\r\n\r\n  /**\r\n   * Get the list of tokens name\r\n   * @returns\r\n   */\r\n  getTokensName(): (keyof T | D)[] {\r\n    return [...Object.keys(this.options.tokens), this.getDefaultType()];\r\n  }\r\n\r\n  /**\r\n   * Check if a given token match the start of the string\r\n   * @param str\r\n   * @param type\r\n   * @param reg\r\n   * @returns\r\n   */\r\n  private matcher(\r\n    str: string,\r\n    type: string,\r\n    reg: RegExp\r\n  ): MatcherResult<T, D, A> | null {\r\n    reg.lastIndex = 0;\r\n    const match = reg.exec(str);\r\n\r\n    if (!match) return null;\r\n\r\n    return {\r\n      type,\r\n      value: match[0],\r\n      groups: match.groups,\r\n      index: match.index,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Tokenize a string\r\n   * @param str\r\n   * @returns\r\n   */\r\n  tokenize(str: string): Token<T, D, A>[] {\r\n    if (typeof str !== \"string\") return [];\r\n\r\n    const tokens: Token<T, D, A>[] = [];\r\n\r\n    const defaultType = this.getDefaultType();\r\n    const concatDefaultType = this.options.concatDefaultType;\r\n    const tokensList = this.options.tokens;\r\n\r\n    for (let charIndex = 0; charIndex < str.length; ++charIndex) {\r\n      const strToDo = str.substring(charIndex, str.length);\r\n      const strDone = str.substring(0, charIndex);\r\n\r\n      const defaultResult: MatcherResult<T, D, A> = {\r\n        type: defaultType,\r\n        value: strToDo.charAt(0),\r\n        index: 0,\r\n      };\r\n      let result = defaultResult;\r\n\r\n      // Check if any regex is matching\r\n      const reversedTokens = Object.entries(tokensList).reverse(); // For prioretisation\r\n      for (const [type, reg] of reversedTokens) {\r\n        const match = this.matcher(strToDo, type, reg);\r\n        if (match !== null) {\r\n          if (match.index === 0) {\r\n            result = match; // If the index is 0 we found the token\r\n          } else if (\r\n            this.options.prioritize &&\r\n            result !== defaultResult &&\r\n            result.value.length > match.index // Check if the current matching token that have a bigger priority, than the last one, don't have conflict with the last matched token\r\n          ) {\r\n            result = defaultResult;\r\n          }\r\n        }\r\n      }\r\n\r\n      const splittedValueOnLines = result.value.split(/\\n/g);\r\n\r\n      const startLine = strDone.match(/\\n/g)?.length ?? 0;\r\n      const endLine = startLine + Math.max(splittedValueOnLines.length - 1, 0);\r\n      const startColumn = strDone.split(/\\n/g)?.[startLine]?.length ?? 0;\r\n      const endColumn =\r\n        splittedValueOnLines[splittedValueOnLines.length - 1].length +\r\n        (startLine === endLine ? startColumn : 0);\r\n\r\n      let token: Token<T, D, A> | null = {\r\n        type: result.type,\r\n        value: result.value,\r\n        ...(result.groups ? { groups: result.groups } : {}),\r\n        startLine,\r\n        startColumn,\r\n        endLine,\r\n        endColumn,\r\n      };\r\n\r\n      token = this.options.callback\r\n        ? this.options.callback(token, tokens)\r\n        : token;\r\n\r\n      // We update the char index based on what we have match\r\n      charIndex += result.value.length - 1;\r\n\r\n      // Check the new token returned by the callback\r\n      if (token === null) continue;\r\n      if (\r\n        !this.options.authorizeAdditionalTokens &&\r\n        !this.getTokensName().includes(token.type as keyof T | D)\r\n      ) {\r\n        throw new Error(\r\n          `Unknown token type returned by the callback: \"${\r\n            token.type as string\r\n          }\" (If you want to allow other types please set authorizeAdditionalTokens to true)`\r\n        );\r\n      }\r\n\r\n      const isTokenDefaultType = token.type === defaultType;\r\n      const needConcatenation =\r\n        concatDefaultType &&\r\n        isTokenDefaultType &&\r\n        tokens.length !== 0 &&\r\n        tokens[tokens.length - 1].type === defaultType;\r\n      if (needConcatenation) {\r\n        // Concatenation with the last token if needed\r\n        const lastToken = tokens[tokens.length - 1];\r\n        lastToken.value += token.value;\r\n        lastToken.endColumn = token.endColumn;\r\n        lastToken.endLine = token.endLine;\r\n      } else {\r\n        tokens.push(token);\r\n      }\r\n    }\r\n\r\n    return tokens;\r\n  }\r\n}\r\n\r\nexport default Tokenizer;\r\n"],"names":["defaultOptions","defaultType","concatDefaultType","prioritize","Tokenizer","constructor","_options","tokens","Error","this","options","Object","assign","getDefaultType","getTokens","getTokensName","keys","matcher","str","type","reg","lastIndex","match","exec","value","groups","index","tokenize","tokensList","charIndex","length","strToDo","substring","strDone","defaultResult","charAt","result","reversedTokens","entries","reverse","splittedValueOnLines","split","startLine","_b","_a","endLine","Math","max","startColumn","_e","_c","endColumn","token","callback","authorizeAdditionalTokens","includes","isTokenDefaultType","lastToken","push","BUILT_IN_RULES","WORD","NUMBER","ONE_LINE_COMMENT","MULTIPLE_LINE_COMMENT","STRING","DOUBLE_QUOTE_STRING","SINGLE_QUOTE_STRING","GRAVE_ACCENT_STRING","WHITE_SPACES","NEW_LINES"],"mappings":"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"}